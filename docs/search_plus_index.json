{"./":{"url":"./","title":"はじめに","keywords":"","body":"mirameet vol.31_Vue.js　現場で役立つ実践Vue.js!～ECサイトを作成してみる～ 事前準備 VSCodeインストール Dockerインストール 今回の流れ 以下内容についてハンズオンしていきます。 商品検索の共通ヘッダーを実装してみる（component） 商品検索画面の初期表示処理を実装してみる（created, mounted） 商品をカートに入れる機能を実装する（Vuex） 商品の合計金額を自動で算出する（computed） 手順 環境構築①：デモアプリクローン 環境構築②：デモアプリの起動、動作確認 アプリケーションコード修正（商品検索画面） アプリケーションコード修正（商品詳細画面） アプリケーションコード修正（カート画面） 作成したコンテナの削除 "},"create_env_no1.html":{"url":"create_env_no1.html","title":"環境構築 1","keywords":"","body":"環境構築 その１ Django APIサーバーをDocker環境で準備 はじめに今回のハンズオンの環境構築を行いたいと思います。まずは、Vueの環境を立てる前にサーバーサイドとして使用するDjangoフレームワークを用いてAPIサーバーを準備します。 vscodeの拡張機能の確認 vscodeの拡張機能で、「ESLint」「Vetur」が入っているか確認してください。 1-1. 拡張機能を開く 1-2.「ESLint」「Vetur」をインストールされているか確認する。まだの場合はインストールする。ESLint :保存時に自動フォーマットしたり、コードの構文チェックをしてくれる。 Vetur :vue.jsでシンタックスハイライトしてくれる。vscodeでvue.jsを扱うならほぼ必須。 インストールした場合は、vscodeを一度閉じて、再起動してください。 githubリポジトリにアクセス 2-1. 以下リンクよりデモアプリのあるGithubリポジトリにアクセスします。URL:https://github.com/miracleave-ltd/mirameetVol31-Vue.js ソースコードダウンロード 3-1.Codeボタンより、Zipファイルをダウンロードします。 ソースコード展開 4-1.ダウンロードしたZipファイルを任意のフォルダに展開してください。※次の手順を進めるに当たり、展開されたフォルダをVSCodeで開くようお願いします。ファイル フォルダーを開く client > ecsiteを選択して開く サーバーの起動 一度ローカルでサーバーを立ち上げましょう。5-1. Docker Desktopの起動確認docker Desktopが起動できていることを確認します 5-2. Dockerのbuildと起動の確認コマンドをVSCodeのターミナル上から実施し、Dockerの起動を行います。ターミナル > 新しいターミナル以下コマンドでdocker-compose.ymlがあるフォルダに階層を移動します。 cd ../../ 以下コマンドを実行し、コンテナをビルドします。 docker-compose up -d --build dockerが起動しているか以下のコマンドで確認してみましょう。 docker-compose ps Name Command State Ports -------------------------------------------------------------------------------------------------- mirameet_vol30_20220314_client_1 docker-entrypoint.sh node Up 0.0.0.0:8080->8080/tcp mirameet_vol30_20220314_server_1 python manage.py runserver ... Up 0.0.0.0:8040->8000/tcp state が Up となっていれば問題ありません。 "},"create_env_no2.html":{"url":"create_env_no2.html","title":"環境構築 2","keywords":"","body":"環境構築 その 2 Vue アプリケーションを Docker 環境で準備 続いて Vue アプリケーションの準備に移ります。 ecsite ディレクトリ直下を vscode で開いていることを確認してください。vscode が正常に動作しないことがあります。 以下が ecsite ディレクトリになります。 mirameetVol31.-main/client/ecsite Docker コンテナに入って npm install を実行 1-1.Vue プロジェクトに必要なパッケージをインストールするためにまずは下記のコマンドで Docker コンテナに入ります。 docker-compose exec client sh 1-2.ターミナル上に /usr/src と表示されていればコンテナに入れています。Docker コンテナ内に入ったら npm で vue/cli をインストールします。 （少し時間がかかります） npm install -g @vue/cli 1-3.vue/cli のインストール終了後に、続いて、以下コマンドで node_modules フォルダ上に必要なパッケージ類がインストールされます。(通信環境によってしばらく時間がかかります。) npm install --save --legacy-peer-deps Vue アプリケーションサーバーをたてる 2-1.npm でパッケージインストールが完了したら引き続き Docker 内で以下コマンドで Vue アプリケーションを立てましょう。ビルドには少々時間がかかります。 npm run serve 以下の表示になったら起動完了です。 ブラウザから起動確認をしましょう。 3-1.以下の URL でブラウザ上から起動の確認を行ってください。url: http://localhost:8080 "},"component.html":{"url":"component.html","title":"コード修正(App.vue)","keywords":"","body":"コード修正(App.vue) 当手順では、以下の赤枠部分を実施します。 当画面に関連するソースファイル  src\\App.vue ← 修正対象  src\\components\\Header.vue  src\\router\\index.js 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては何もない状態であることがわかったかと思います。 確認できたところで、あらためて修正をすすめていきましょう！ src\\App.vueの修正 vueファイルは主に ・templateタグ：html要素を記述する ・scriptタグ：javascriptの処理を記述する ・styleタグ：cssを記述する の三つのタグからなります。 これらを合わせて一つのコンポーネントとして作成し、 それら組み合わせて1つのページを作るのがVue.jsの大枠の考え方です。 コンポーネントを呼び出すにはまずscriptタグ内で呼び出すコンポーネントのvueファイルをインポートし、 components要素内に使用するコンポーネント名を記載します。 その後templateタグ内で、呼び出すコンポーネント名をそのままタグとして記載してあげれば、その場所に子コンポーネントが挿入されます。 ヘッダーをインポートして画面に配置しよう。 src\\App.vue にヘッダー用のコンポーネントをインポートし、画面上に配置します。 Ctrl+P(MACの場合Command+P) を押下してファイル検索を表示し、「App.vue」を開きます。 ソースを以下のように修正してください。修正したら、ファイルを上書き保存してください。 修正前 修正後 // Header.vueをインポート import Header from './components/Header' // components にHeader追加する export default { name: 'App', components: { Header } } 画面上部にヘッダーが実装できました。 補足:ルーティングの説明 app.vueの以下の部分(Vue Router) Vue Routerとは、 Vue.jsを利用したSPA構築で、ルーティング制御をするための公式プラグインです。 src\\router\\index.js内に、アプリケーションのルーティングを記述しています。 import Vue from 'vue' import VueRouter from 'vue-router' import ItemSearch from '../views/ItemSearch.vue' import Cart from '../views/Cart.vue' import DetailView from '../views/DetailView.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', component: ItemSearch }, { path: '/cart', name: 'cart', component: Cart }, { path: '/detail', name: 'detail', component: DetailView } ] const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) export default router pathに書かれたURLにアクセスすると、componentに設定されたページ内容を 「router-view」のエリアで表示します。 今回の場合は上記記述によって、ヘッダーは常に共通のものが表示、URLが変更されると 「router-view」の内容がそのURLに設定されたページを表示してくれます。 次の手順では、ヘッダー内の修正を行っていきます！ "},"header.html":{"url":"header.html","title":"コード修正(ヘッダー)","keywords":"","body":"コード修正(ヘッダー) 当手順では、以下の赤枠部分を実施します。 修正対象のソース src\\components\\Header.vue 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 「大分類」から、何か選択した状態で「中分類」のリストをクリックしてみてください。 特にフィルタリング処理は実装されておらず、大分類を変更しても中分類リストの選択肢一覧に変更がないことが分かったかと思います。 computed のおさらい computed についておさらいします。 業務において、データに何かしらの処理を加えてから表示させたい。という場面があると思います。 そんな時に使えるのが computed プロパティです。 computed は一度計算後、同じ処理が呼び出された際も以前計算時にキャッシュされたデータを即時返すだけなので何度も同じ処理を行いません。 キャッシュが削除され再度計算されるのは、依存するデータの値が更新されたときだけです。 methods は結果をキャッシュしないので、一度計算を行った場合でも、呼び出されるたびに再計算が行われます。 computed と watch の違いのおさらい watch とは、特定のデータまたは computed プロパティの状態を監視して、変化があったとき登録した処理を自動的に実行するものです。 データの変更を監視して、それをトリガーに処理を行う必要がある時に使えます。 具体的には ・computed プロパティでは処理できない非同期通信などの複雑な処理を行う場合 ・処理の中で更新前と更新後の値を使う場合 ・処理を実行しても、データは返さない場合 上記にあたる場合は watch を使って処理をすることが望ましいでしょう。 今回のハンズオンでは、watch は使いませんが、実務では使うことも多いので、是非覚えておいてください。 computed を使ってフィルタリング処理を実装しよう。 おさらいを確認したうえで、、あらためて修正をすすめていきましょう！ Ctrl+P(MAC の場合 Command+P) を押下してファイル検索を表示し、「Header.vue」を開く Ctrl+F(MAC の場合 Command ＋ F) で検索欄を表示し、「filterdMediumCategory」内にフィルタリング処理を記述する。中分類リストの選択肢内容を、大分類の選択値に基づいて動的にフィルタリング処理をかけてみましょう。 filterdMediumCategory を以下のように修正してください filterdMediumCategory: function () { if (this.lergeCategoryCode === '') { return this.mediumCategoryList } return this.mediumCategoryList.filter((row) => { return row.parentCode === this.lergeCategoryCode }) } 修正した filterdMediumCategory によってヘッダーの中分類選択肢リストが、大分類リストの選択値によって、フィルタリングがかかるようになりました。 大分類で「周辺機器」を選択すると、中分類リストが「ノートパソコン」「デスクトップパソコン」「ディスプレイ」に絞り込まれます。 次の手順では、商品検索画面の修正を行います！ "},"item_search.html":{"url":"item_search.html","title":"コード修正(商品検索)","keywords":"","body":"コード修正(商品検索画面) 当手順では、以下の赤枠部分を実施します。 修正対象のソース src\\views\\ItemSearch.vue 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては、「商品検索画面」と表示されるのみで、商品一覧は検索されていないことがわかります。 確認できたところで、あらためて修正をすすめていきましょう！ created を使って画面初期表示時の処理を実装しよう。 Ctrl+P(MAC の場合 Command ＋ P) を押下してファイル検索を表示し、「itemSearch.vue」を開く。Ctrl ＋ F(MAC の場合 Command+F) で検索欄を表示し、「created」内に初期表示時の処理を記述する。今回は、クエリパラメータを受け取って検索処理を行う「search()」を初期表示時に実行するようにしてみます。created を以下のように修正してください 修正前 修正後 created: function () { // 初期表示時処理 this.search() }, 初期表示時に search()メソッドを呼び出すことによって、画面初期表示時に商品一覧の検索処理が行われるようになりました！ 大分類、中分類を選択したり、検索ワードを入れて検索ボタンを押下すると、絞り込まれたリストが表示されます。 created についておさらい created は画面初期表示時に走る処理です。正確に言うと Vue のインスタンスが生成され､データが初期化された後に実行されます。初期表示時に実施したい処理がある場合はこの created に処理をかいていくことで実装することができます。今回の場合は画面が初期表示される際に検索処理を行いたかったため、search メソッドを呼び出すように変更しました。created は実際の開発でもよく使うライフサイクルフックの一つですので、ぜひ覚えておいてください！ mounted との違い created と mounted は共に画面初期表示時に走る処理です。mounted は、Vue インスタンスが DOM 要素にマウントされた後に実行される処理です。getElementById 等を使って DOM 要素にアクセスをしたい場合は、mounted に書くことが望ましいです。created の時に getElementById('hoge')で DOM の要素を取得しようとしても取得することはできません。mounted が実行されるタイミングでは DOM の作成が完了しているので DOM の要素が取得できるためmounted も、created と並んでよく使うライフサイクルフックです。初期表示処理は mounted でまとめて行う、という現場もあります。 次の画面では、商品詳細画面の修正を行います！検索結果一覧に表示されている商品画像の何れかをクリックし、商品詳細画面へ移動しましょう！ "},"item_detail.html":{"url":"item_detail.html","title":"コード修正(商品情報詳細)","keywords":"","body":"コード修正(商品情報詳細) 修正対象のソース src/store/index.js src/views/DetailView.vue 続いては商品詳細画面です。 この画面は、検索画面で選択した商品の詳細情報が掲載されています。またこの画面でポイントとなるのは、商品をカートに入れる機能です。 商品をカートに追加するための機能を実装しよう。 src/store/index.js ← 修正するファイル 修正する前に一度、状況を確認してみましょう。http://localhost:8080/detail?itemCode=2商品の個数を選択して、カートに入れるボタンを押下してみてください。「カートに追加しました。」というダイアログが出て、OK ボタンを押下すると検索画面へ戻ります。 では、この状態でカート画面へ遷移してみましょう。http://localhost:8080/cart先ほどカートに商品を追加したはずですが、カート画面を開いてみても、何も表示されません。 確認できたところで、改めて修正を進めていきましょう。 今回は Vuex というライブラリを使用して、商品をカートに入れます。 \"Vuex\"とは Vue.js アプリケーションのための 状態管理パターン + ライブラリです。 https://vuex.vuejs.org/ja/ (Vue.js 公式サイトより) では、実際に修正していきましょう。今回修正する箇所は\"src/store/index.js\"の\"mutations\"の箇所です。mutations にカートに入れるボタンを押下した際に、商品情報を保持するための処理を追加します。src/store フォルダ内の index.js を開き、「mutations」を検索します。 修正前 修正後 mutations の中に商品追加の処理「pushItem」を追加してください。 mutations: { // 商品追加 pushItem (state, item) { // 引数で渡された配列をまるごとpush state.itemList.push(item) }, // 商品削除 deleteItem (state, item) { // 引数で渡された行を削除 state.itemList.splice(item, 1) }, // 商品リスト初期化 clearItem (state) { state.itemList = [] } }, pushItem は渡された引数を、itemList という名前のリスト変数に追加します。これで商品情報を保持させることができます。 カートに入れる機能を追加しよう。 src/views/DetailView.vue ← 今回修正するファイル ここでは、商品検索で選択した商品情報をカートに入れる処理を追加します。 methods の中にある「additem」の処理を下記のように修正してみましょう。Ctrl+P(Mac の場合 Command+P)で、「detailView.vue」ファイルを開き、「addItem」を検索します。 修正前 修正後 addItem () { // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } addItem の下に商品情報を保持するためのソースを追加してください。 addItem () { // storeに保存後ダイアログ表示して検索画面に戻る const param = { name: this.productName, description: this.description, price: this.price, quantity: Number(this.quantity), imageUrl: this.img // 商品画像 } this.$store.commit('pushItem', param) // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } まず画面に表示されている商品のパラメーターをオブジェクト param に設定します。それぞれ商品名・商品説明・値段・数量・商品画像です。 次に先ほど追加した「pushItem」を呼び出して商品情報を store に追加します。書き方としては、this.$store.commit('呼び出す処理名',処理に渡す引数)で store の state の値を変更します。第一引数を store/index.js の mutations に追加した pushItem にします。第二引数は商品情報をもった変数 param にすることで、store/index.js の state の itemList に商品情報を追加します。 カート画面では store の保持している itemList を、getters を使用することでカート画面上に表示させています。 動作確認 動作確認をしてみましょう。 商品詳細画面内の個数プルダウンで任意の商品数を選択肢し、商品を購入のボタンをクリックしてください。 下記のように完了のダイアログが表示され検索画面に遷移します。商品がカートに入っているか確認してみましょう。画面右上のショッピングカートのアイコンをクリックすることで、カート画面へ遷移します。カートに入れた商品が表示されることがわかるかと思います。 次の手順では、今開いたカート画面のソースコードのリファクタリングを行います！商品を何種類かカートへ追加し、カート画面へ遷移しましょう！ "},"cart.html":{"url":"cart.html","title":"コード修正(カート)","keywords":"","body":"コード修正(カート) 確認対象のソース src/views/Cart.vue 既存コードを確認しよう。 カート画面上に商品詳細画面でカートに追加した商品が表示されています。画面右側に商品の合計値が表示されていますね。カートに入っている商品を削除ボタンで削除してみると、合計額が変更されるのを確認できると思います。カート画面のソースを確認すると、 mounted の際にも、handleDelete にも合計値取得処理（this.getTotal())が記載されています。 mounted: function () { // DOMのマウント終了後の処理 /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, methods: { /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, /** *合計値取得 */ getTotal () { let price = 0 this.getItemList.forEach(element => { price += element.price * element.quantity }) return price } }, 今まで登場した Vue.js の機能を使えば、削除ボタンのクリックイベント発火時に毎回合計値取得処理を明示的に呼び出す必要がなくなります。ここで今日のハンズオン参加者の皆様にクイズです。ここで利用するべき Vue.js の機能とは一体何でしょうか？ created mounted computed皆さん、考えてみましょう！ "},"cart_answer.html":{"url":"cart_answer.html","title":"コード修正(カート) 回答","keywords":"","body":"コード修正(カート) 回答編 修正対象のソース src/views/Cart.vue 答え合わせです！正解はcomputedになります！created→ 画面初期表示時のライフサイクルフックなので、画面初期表示時に一度実行された後、再計算は行われない。mounted→ 同様に画面初期表示時のライフサイクルフック(created の後に実行される)なので、初期表示時に一度実行された後、再計算は行われない。computed→ 計算結果に依存する getItemList()の値が変更される度、自動的に再計算される。早速、computedを使ってコード修正を行ってみましょう！ ソースコードの修正 mounted と handleDelete から合計値取得処理を削除して、getTotal method を computed 内に書き換えます。 修正後mountedthis.totalPrice = this.getTotal()を削除 mounted: function () { // DOMのマウント終了後の処理 }, methodsgetTotal()メソッドを削除。 handleDelete メソッドから、this.totalPrice = this.getTotal()を削除する。 getPrice (price, quantity) { return Number(price * quantity) }, /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) }, computedgetTotal()処理を追加 computed: { getItemList () { return this.$store.getters.getItemList }, getTotal () { let price = 0 this.getItemList.forEach(element => { price += element.price * element.quantity }) return price } }, template タグ内で合計額表示している箇所の「totalPrice」をcomputed に定義した 「getTotal」 に書き換えます。 修正前 修正後 ￥{{ getTotal | money }}円 商品を購入 修正内容の確認 ブラウザをリロードしてみて表示されている内容に問題がないか確認してみましょう。機能としては、修正前と同じく、商品をカートから削除した際に合計額が再計算されます。 ソースコード上では mounted,handleDelete の複数箇所で毎回同じ処理を呼び出す事がなくなり、computed の処理一つに集約したことで修正を行う際にも修正箇所が減りました。このように、プログラムの外部から見た動作を変えずにソースコードの内部構造を整理することをリファクタリングと言います。実務においてもリファクタリングを行う場面は多々あると思います。ぜひ覚えておいてください！ "},"cleanup.html":{"url":"cleanup.html","title":"local環境のCleanUp","keywords":"","body":"local 環境の CleanUp 今回のハンズオンで使用した開発環境の削除を行います。 コンテナの停止 新しくターミナルを開き、以下コマンドで Docker コンテナを停止します。 docker-compose down コンテナが停止しているか確認します。以下のコマンドを使用します。 docker-compose ps 以下の状態になれば、コンテナが停止しています。 Name Command State Ports ------------------------------ イメージの削除 以下コマンドを使用して、IMAGE IDを確認します。 docker images REPOSITORY TAG IMAGE ID CREATED SIZE mirameetvol29_server latest ba2bac2d2844 4 days ago 197MB mirameetvol29_client latest 05b82c10dc6e 6 days ago 111MB 上記で確認できた IMAGE ID を利用して、ビルドされたイメージを削除します。 docker rmi -f [IMAGE ID] 次のようなメッセージが確認できたら、イメージが正常に削除出来ています。 Untagged: meetup_web... フォルダの削除 最後にフォルダを削除します。 以上で本日のハンズオンは終了となります。皆様お疲れ様でした！ "}}